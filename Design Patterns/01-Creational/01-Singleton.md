**Singleton** არის **დიზაინის პატერნი**, რომელიც უზრუნველყოფს კლასის **მხოლოდ ერთი ინსტანციის** შექმნას და მისი ხელმისაწვდომობას გლობალურად.

PHP - ში **Singleton** ხშირად გამოიყენება:
- **მონაცემთა ბასიზს კავშირში** - ერთიანი კავშირის უზრუნველსაყოფად.
- **ლოგირების სისტემა** - ერთიანი ობიექტის გამოყენებისთვის.
- **კონფიფურაციის მართვაში** - ცენტრალიზირებული პარამეტრების შენახვისთვის.

---

**რატომ გამოვიყენოთ Singleton?

✅ **მხოლოდ ერთი ობიექტი** - ვუზრუნველყოფთ, რომ ერთი და იგივე კლასი მრავალჯერ არ შეიქმნება.
✅ **გლობალური წვდომა** - ობიექტს შეგვიძია მივწვდეთ კოდის ნებისმიერი ადგილიდან.
✅ **რესურსების დაზოგვას** - თავიდან ვიცილებთ ზედმეტი ობიექტების შექნას რომლებიც ადგილს იკავებენ ოპერატიულ მეხსიერებაში, ასევე მონაცემთ ბაზის შემთხვევაში თავიდან ვირიდებთ ზედმეტ კავშირებს მონაცემთა ბაზასთიან.

---

## 1. Singleton - ის იმპლემენტაცია

დავწეროთ **მონაცემთა ბაზის Singleton კლასი,** რომელიც იყენებს **PDO**-ს.

```php
class Database {
    private static ?Database $instance = null;
    private \PDO $connection;

    // პრივატული კონსტრუქტორი - აკრძალავს new Database() გამოყენებას
    private function __construct() {
        try {
            $this->connection = new \PDO("mysql:host=localhost;dbname=testdb", "root", "");
            $this->connection->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);
        } catch (\PDOException $e) {
            die("Connection failed: " . $e->getMessage());
        }
    }

    // აბრუნებს ამ კლასის მხოლოდ ერთ ობიექტს
    public static function getInstance(): Database {
        if (self::$instance === null) {
            self::$instance = new Database();
        }
        return self::$instance;
    }

    // მონაცემთა ბაზის კავშირის დაბრუნება
    public function getConnection(): \PDO {
        return $this->connection;
    }

    // აიკრძალოს კლონირება
    private function __clone() {}

    // აიკრძალოს unserialize()-ით ობიექტის აღდგენა
    private function __wakeup() {}
}

// გამოყენება:
$db1 = Database::getInstance();
$db2 = Database::getInstance();

// ორივე ცვლადი ერთი და იმავე ობიექტს მიუთითებს
var_dump($db1 === $db2); // true

// ეს გამოიწვევს შეცდომას (Fatal Error: Uncaught Error: Call to private Database::__clone())
// $db3 = clone $db1;

// ესეც გამოიწვევს შეცდომას (Fatal Error: Uncaught Error: Call to private Database::__wakeup())
// $db4 = unserialize(serialize($db1));
```

---

### როგორ მუშაობს ეს კოდი?

- **private function __constructor()**
	- **კონსტრუქტორი დახურულია,** რათა თავიდან ავირიდოთ **new Database()** - ის გამოყენება.
	- **PDO**-ს მეშვეობით მონაცემთა ბაზასთან კავშირი იქმნება.
-  **public static function getInstance()**
	- თუ ობიექტი **ჯერ არ შექმნილა**, იგი იქმნება და ინახება self::$instance - ში.
	- თუ ობიექტი უკვე არსებობს, ის უბრალოდ ბრუნდება.
- **private function __clone()**
	- **აიკრძალა** clone ოპერატორის გამოყენება.
- **private function __wakeup()
	- **აიკრძალა** serialize() და unserialize() მეთოდებით ობიექტის დუბლირება.

---

### Singleton - ის დადებითი და უარყოფითი მხარეები

#### დადებითი მხარეები

✅ **მხოლოდ ერთღი ობიექტი** - რესურსების ოპტიმიზაცია.
✅ **მონაცემთა ბაზის ეფექტური მართვა**.
✅. **გლობალური წვდომა**.

#### უარყოფითი მხარეები

**❌ გლობალური მდგომარეობა** - რთულია მოსავლელად.
**❌ გართულებული ტესტირება** - არ მუშაობს კარგად DI სთან ერთად.
**❌ მოდულარობის შემცირება.**

---

**🚀 დასკვნა**

**Singleton Pattern** PHP-ში **ძლიერი ინსტრუმენტია**, რომელიც შეიძლება სწორად გამოყენების შემთხვევაში მნიშვნელოვნად გააუმჯობესოს აპლიკახიის მუშაობა, თუმცა, მისის არასწორად გამოყენება შეიძლება პრობლემად იქცეს, ამიტომ **უნდა გამოვიყენოთ მხოლოდ აუცილებელი საჭიროების შემთხვევაში**.

**გაითვალისწინეთ**:

თუ **ტესტირებადობა** და **მოქნილობა** მნიშვნელოვანია, უკეთესია Dependency Injection  ის გამოყენება.