**InnoDB** არის MySQL ის ძირითადი **Storage Engine**, რომელიც უზრუნველყოფს ACID თვისებებს (Atomicity, Consistency,Isolation, Durability) და მხარს უჭერს ტრანზაქციებს.
ერთ-ერთი მთავარი მექანიზმი კომპონენტი, რომელიც InnoDB-ს ამ ფუნქციონალის მხარდაჭერის საშუალებას აძლევს, არის დაბლოკვის მექანიზმი. დაბლოკვა (Locking)
იცავს მონაცემებს ერთდროულად წვდიმისას, რათა არ მოხდეს მონაცემთა დაზიანება ან შეუსაბამობა.

ამ დოკუმენტში განვიხილავთ **InnoDB - ის დაბლოკვის ტიპებს, მათ მუშაობის პრინციპებს და საუკეთესო პრაქტიკებს**, რაც დაგეხმარებათ კონკრეტულ გარემოში მონაცემთა ბაზის ეფექტურად მართვაში.

---

### 1. დაბლოკვის ტიპები InnoDB - ში
InnoDB იყენებს დაბლოკვის რამდენიმე ტიპს, რომლებიც უზრუნველყოფენ სხვადასხვა დონის იზოლაციას და კონკურენტულობის მხაედაჭერას.

#### 1.1. Row-Level Locking (ჩანაწერის დონეზე ბლოკირება)

ეს არის InnoDB -ის ყველაზე ხშირად გამოყენებადი დაბლოკვის მექანიზმი, რომელიც ბლოკავს კონკრეტულ ჩანაწერს, ნაცვლად მთლიანი ცხრილისა.

**დადებითი მხარეები:**
- ზრდის კონკურენტულობას, რადგან სხვა ტრანზაქციებმა შეიძლება იმუშავონ იმავე ცხრილზე, თუ მათ არ სჭირდებათ დაბლოკილი ჩანაწერი.
- ამცირებს დალოდების (wait) და deadlock ის შანსებს.

##### მაგალითი:

```sql
SELECT * FROM users WHERE id = 1 FOR UPDATE;
```

აქ **FOR UPDATAE** - ის გამოყენება ნიშნავს, რომ კონკრეტული ჩანაწერი სადაც **id = 1** დაიბლოკოს სხვა ტრანზაქციებისთვის, სანამ მიმდინარე ტრანზაქცია არ დასრულდება.

#### 1.2. Table-Level Locking (ცხრილის დონეზე დაბლოკვა)

ცხრილის დაბლოკვა მთლიანად ბლოკავს ცხრილს, რაც ნიშნავს რომ სხვა ტრანზაქციები ვერ განახორციელებენ ამ ცხრილზე ოპერაციებს, სანამ დაბლოკვა არ მოიხსნება.

**უარყოფითი მხარეები**
- ამცირებს კონკურენტულობას, რადგან სხვა ტრანზაქციები ვერ იმუშავებენ ამ ცხრილზე სანამ დაბლოკილია.
- შეიძლება გამოიწვიოს დიდი შეფერხებები დიდ დატვირთვაზე.

##### მაგალითი:
```sql
LOCK TABLES orders WRITE;
```
ეს ბრძანება **ბლოკავს** orders ცხრილს ჩანაწერისთვის, სანამ 
```sql
UNLOCK TABLES
```
 არ მოხდება .

#### 1.3. Shared Locks (S Locks) - გაზიარებული დაბლოკვა

გაზიარებული (shared) დაბლოკვა გამოიყენება, როდესაც გვჭირდება მონაცემების წაკითხვა, მაგრამ არ ვაპირებთ მათ შეცვლას.
სხვა ტრანზაქციებს შეუძლიათ იგივე ჩანაწერის გაზიარებული დაბლოკვის დადება, მაგრამ ჩაწერა შეუძლებელია, სანამ ყველა გაზიარებული ბლოკი არ მოეხსნება.

##### მაგალითი: 
```sql
SELECT * FROM products WHERE id = 10 LOCK IN SHARE MODE;
```

ეს ნიშნავს, რომ ჩანაწერს სადაც **id = 10** დაბლოკილია ჩაწერისთვის მარა მისი წაკითხვა სხვა ტრანზაქციებსაც შეუძლიათ.

#### 1.4. Exclusive Locks (X-Locks) - ექსლუზიური დაბლოკვა

ექსკუზიური დაბლოკვა გამოიყენება მაშინ. როდესაც საჭიროა ჩანაწერის შეცვლა. როდესაც ჩანაწერი ექსკლუზიურად არის დაბლოკილი, სხვა ტრანზაქციები ვერ წაიკითხავენ და ვერ შეცვლიან ამ ჩანაწერს.

##### მაგალითი: 

```sql
UPDATE employees SET salary = salary * 1.1 WHERE id = 5;
```

InnoDB ავტომატურად აწესებს ექკლუზიურ ბლოკს ჩანაწერზე სადაც **id = 5**, სანამ ტრანზაქცია არ დასრულდება.

---

### 2. DeadLock (ჩაკეტვა) და მისი თავიდან აცილება

**DeadLock** ხდება მაშინ, როდესაც ორი ან მეტი ტრანზაქცია ერთმანეთს ელოდება და ორივეს უნდა ერთ რესურსზე წვდომა, ეს იწვევს უსასრულო ციკლს.

#### მაგალითი:

```sql
-- ტრანზაქცია 1
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- ტრანზაქცია 2
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 2;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
```

#### DeadLock ის თავიდან აცილების სტრატეგიები

1. **ტრანზაქციების თანმიმდევრული შესრულება**
2. **LOCK_TIMEOUT - ის გამოყენება** - დაყოვნებული ტრანზაქციები შეიძლება ავტომატურად შეწყდეს. `SET innodb_lock_wait_timeout = 5;`
3. **მოკლე ტრანზაქციები** - რაც მოკლეა ტრანზაქცია, მით ნაკლებია Deadlock ის საფრთხე.


#### რა ხდება DeadLock ის შემდეგ

როდესაც მონაცემთა ბაზა დააფიქსირებს DeadLock ს მაშინ ის თვითონ შეწყვეტს ერთერთ ტრანზაქციას, გააკეთებს **ROLLBACK** - ს და კლიენტს დაუბრუნდება შეცდომა:

```sql
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

**აპლიკაციის დეველოპერი პასუხისმგებელი აპლიკაციაში თავად გაითვალისწინოს ისეთი სცენარი როცა მონაცემთა ბაზა გააკეთებს ROLLBACK ს.**

---

### 3. ბაზის საუკეთესო პრაქტიკები Locking მექანიზმებთან მუშაობისთვის

- **გამოიყენეთ FOR UPPDATE მხოლოდ მაშინ, როდესაც აუცილებელია.
- **წინასწარ განსაზღვრეთ, რომელი ოპერაციები იწვევენ ჩაკეტვას და ოპტიმიზაცია გაატარეთ.
- **გამოიყენეთ LOCK IN SHARE MODE მხოლოდ წაკითხვის ოპერაციებისთვის, რათა თავიდან აიცილოთ მონაცემთა დაბლოკვა.
- **მონიტორინგისთვის გამოიყენეთ SHOW ENGINE INNODB STATUS; ბრძანება რათა ნახოთ აქტიური დაბლოკვები და DeadLock ები.






