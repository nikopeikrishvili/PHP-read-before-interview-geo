
**Iterator Pattern** არიუს ქცევითი ტიპის პატერნი, რომელიც საშუალებას გვაძლევს **კოლექციის ელემენტებზე თანმიმდევრულ ქვდომას მისი შიდა სტრუქტურის გამჟღავნების გარეშე**. ეს პატერნი განსაკუთრებით სასარგებლოა, როდესაც ვმუშაობთ კოლექციებთან (მაგალითად, მასივებთან სიებთან) და გვჭირდება ელემენტებზე მოქნილი და უსაფრთხო წვდომა.

---

#### რატომ გამოვიყენოთ Iterator პატერნი?

✅ **ინკაფსულაცია** - კოლექციის შიდა სტრუქტურა რჩება დამალული.    
✅ **მოქნილობა** - შეგვიძლია სხვადასხვა მეთოდით ვიმუშავოთ კოლექციასთან.    
✅ **კოდის სისუფთავე** - იტერაციის პროცესი გამოყოფილია კოლექციის მართვისგან.    

---
#### როგორ მუშაობს Iterator პატერნი?

PHP - ს Iterator ინტერფეისი უკვე განსაზღვრული აქვს და მისი გამოყენებით მარტივად შეგვიძლია **Iterator ის შექმნა**. ეს ინტერფეისი მოიცავს შემდეგ მეთოდებს:


| **მეთოდი** | **აღწერა**                                        |
| ---------- | ------------------------------------------------- |
| current()  | აბრუნებს მიმდინარე ელემენტს                       |
| next()     | აბრუნებს შემდეგ ელემენტს                          |
| key()      | აბრუნებს მიმდინარე ელემენტის ინდექსს              |
| valid()    | ამოწმებს, არის თუ არა მიმდინარე ელემენტი ვალიდური |
| rewind()   | აბრუნებს Iterator - ს კოლექციის დასაწყისში        |

---

#### Iterator პატერნის იმპლემენტაცია

##### 1. კოლექციის კლასის შექმნა

შევქმნათღ პროდუქციის კოლექცია, რომელიც ინახავს პროდუქტების სიას:
```php
class ProductCollection implements Iterator {
    private array $products = [];
    private int $position = 0;

    public function __construct(array $products) {
        $this->products = $products;
    }

    public function current(): mixed {
        return $this->products[$this->position];
    }

    public function next(): void {
        $this->position++;
    }

    public function key(): int {
        return $this->position;
    }

    public function valid(): bool {
        return isset($this->products[$this->position]);
    }

    public function rewind(): void {
        $this->position = 0;
    }
}
```

##### იტერატორის გამოყენება

ახლა, შეგვიძლია ProductCollection კლასის ობიექტი შევქმნათ და მასზე იტერაცია გავაკეთოთ:
```php
$products = new ProductCollection(["Laptop", "Mouse", "Keyboard", "Monitor"]);

foreach ($products as $key => $product) {
    echo "Product $key: $product\n";
}
```

##### 3. შედეგი
```
Product 0: Laptop
Product 1: Mouse
Product 2: Keyboard
Product 3: Monitor
```

---
#### როდის გამოვიყენოთ Iterator პატერნი?

✅ როდესაც გვინდა **ინკაფსულირებული (დამალული) კოლექცია** გამოვიყენოთ.    
✅ როდესაც კოლექციაზე წვდომა მოითხოვს **სპეციფიკურ ლოგიკას**.    
✅ როდესაც ვმუშოაბთ **დიდ მონაცემთა ნაკრებთან (large dataset)** და გვინდა მეხსიერების ეფექტურად გამოყენება.

---

#### 🚀 დასკვნა

**Iterator პატერნი** საშუალებას გვაძლევს ელემენტებზე **სტანდარტიზირებულად და მარტივად** ვიმუშავოთ. ის გვაძლევს მოქნილობას და კოდის სისუფთავეს, რა მას **მნიშვნელოვან ინსტრუმენტად აქცევს OOP სივრცეში.