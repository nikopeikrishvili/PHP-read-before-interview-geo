**Proxy** არის სტრუტურული დიზაინის პატერნი, რომელიც გამოიყენება როგორც შუამავალი ობიექტი რომელიც აკონტროლებს წვდომას ნამდვილ ობიექტთან და შეუძლება ფუნქციონალი ინექცია მანამდე ან იმის მერე რაც ნამდვილ ობიექტთან მოხდება მოთხოვნის გაგზავნა.

#### Proxy პატერნი გამოიყენება

1. **წვდომის კონტროლი** - შეზღუდოს კონკრეტული რესურსის ან ობიექტის გამოყენება.
2. **ქეშირება (caching)** - შეინახოს ადრე გამოთვლილი მონაცემები, რათა თავიდან ავიცილოთ ძვირადღირებული ოპერაციები.
3. **ზარმაცი ინიციალიზაცია (Lazy Initialization)** - როდესაც რესურსის შექმნა ძვირადღიებუილია, proxy ობიექტი ქმნის მას საჭიროებისამებრ.
4. **ლოგირება** - აკონტროლოს და დაარეგისტიტოს ობიექტთან წვდომის აქტივობები.

---

#### Proxy პატერნის იმპლემენტაცია

მოდით განვიხილოთ მაგალითი, სადაც გვაქვს **RealSubject** კლასი და **Proxy** კლასი, რომელიც აკონტროლებს მის მუშაობას.

##### 1. ინტერფეისის შექმნა

პირველ რიგში, შევქმნათ ინტერფეისი, რომელიც დააკმაყოფილებს როგორც ნამდვილ ობიექტს (RealSubject), ისე Proxy -ის.
```php
<?php
interface Subject {
    public function request();
}

```

##### 2. ნამდვილი ობიექტის შექმნა

ეს კლასი შეიცავს ძირითად ფუნქციონალს, რომელიც Proxy -ს მიერ უნდა გაკონტროლდეს.
```php
<?php
class RealSubject implements Subject {
    public function request() {
        echo "Executing RealSubject request...\n";
    }
}
```

##### 3. Proxy კლასის შექმნა

Proxy კლასი აკონტოლებს რეალურ ობიექტთან წვდომას.
```php
<?php
class Proxy implements Subject {
    private ?RealSubject $realSubject = null;

    public function request() {
        if ($this->realSubject === null) {
            $this->realSubject = new RealSubject();
        }
        echo "Proxy: Checking access before forwarding request.\n";
        $this->realSubject->request();
    }
}
```

##### 4. გამოყენება (კლიენტის კოდი)

ახლა შეგვიძლია გამოვიყენოთ Proxy კლასის ობიექტი.
```php
<?php
function clientCode(Subject $subject) {
    $subject->request();
}

echo "Using RealSubject directly:\n";
$realSubject = new RealSubject();
clientCode($realSubject);

echo "\nUsing Proxy:\n";
$proxy = new Proxy();
clientCode($proxy);
```

##### 5. შედეგი

ზემოთ მოცემული კოდის გაშვებისას მივიღებთ შემდეგ შედეგს:
```
Using RealSubject directly:
Executing RealSubject request...

Using Proxy:
Proxy: Checking access before forwarding request.
Executing RealSubject request...
```

##### 6. ანალიზი

1. **როდესაც ვიყენებთ RealSubject-ს პირდაპირ**, ის უბრალოდ ასრულებს request() მეთოდს.
2. **როდესაც ვიყენებთ Proxy-ს**,მ ის ჯერ ამოწმებს წვდომას (ან სხვა დამატებითღ ფუნქციებს ასრულებს) და შემდეგ აგზავნის მოთხოვნას ნამდვილ ობიექტისკენ.

---

#### Proxy პატერნის დადებითი და უარყოფითი მხარეები

**✅ უპირატესობები:**
- **ოპტიმიზაცია** - შესაძლოა შემცირდეს სისტემის რესურსების მოხმარება.
- **უსაფრთხოება** - წვდომის კონტოლის შესაძლებლობა.
- **გაფართოაებადობა** - დამატებითი ფუნქციონალის დამატება შესაძლებელია პირდაპირი ჩარევის გარეშე.
- **Hooks(ჰუკები)** - შესაძლებლობა რომ დამატებითი ფუნქციანალის ინექცია მოვახდინოთღ რეალური ობიექტის მეთოდის გამოძახებამდე და გამოძახების მერე, მაგალითად ლოგირებისთვის.
**❌ უარყოფით მხარეები:**
- **კოდის სირთულე** - შესაძლოა საჭირო გახდეს დამატებითი კლასების შექმნა.
- **შედარებით ნელი შესრულება** - დამატებითი შუალედური კლასის არსებობა შეიძლება გავლენას ახდენდეს შესრულების სისწრაფეზე.
---


#### 🚀 დასკვნა
Proxy დიზაინის პატერნი განსაკუთრებით სასარგებლოად, როდესაც საჭიროა მონაცემების caching, წვდომის კონტოლი და ლოგირება.