
**Abstraction (აბსტრაქცია)** არის **ობიექტზე ორიენტირებული პროგრამირების (OOP)** ერთ-ერთი მთავარი პრინციპი რომელიც **ობიექტის მხოლოდ აუცილებელ დეტალებს წარმოაჩენს და ზენდმეტ კომპლექსურობას მალავს.**


## 1. როგორ მიიღწევა აბსტრაქცია PHP-ში?

PHP-ში აბსტრაქცია მიიღწევა **აბსტრაქტული კლასების და ინტერფეისების გამოყენებით.**

| **მეთოდი**                             | **აღწერა**                                                                                                           |
| -------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **abstract class (აბსტრაქტული კლასი)** | არ შეიძლება მისი ობიექტად შექმნა, მაგრამ მასზე დაფუძნებული შვილობილი კლასები კონკრეტულ იმპლემენტაციას უზრუნველყოფენ. |
| **interface (ინტერფეისი)**             | განსაზღვრავს რა მეთოდები უნდა ქონდეს კლასსს, მაგრამ არ შეიცავს კონკრეტულ იმპლემენტაციას.                             |

---
## 2. აბსტრაქტული კლასების (Abstract classes) გამოყენება

**📌 როდის გამოვიყენოთ აბსტრაქტული კლასი?**

✅ როცა გვინდა, რომ **ზოგადი ლოგიკა უკვე განსაზღვრული იყოს**, მაგრამ **ზოგიერთი მეთოდი შვილობილმა კლასებმა განსაზღვრონ.**    

**მაგალითი:**

```php
<?php

abstract class Animal {
    protected string $name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    // აბსტრაქტული მეთოდი (მემკვიდრეობით მიღებული კლასებმა უნდა განახორციელონ)
    abstract public function makeSound(): string;

    public function getName(): string {
        return $this->name;
    }
}

class Dog extends Animal {
    public function makeSound(): string {
        return "Bark!";
    }
}

class Cat extends Animal {
    public function makeSound(): string {
        return "Meow!";
    }
}
$animal = new Animal("Luna"); // ❌ აბსტრაქტული კლასისგან ობიექტს ვერ შექმნით
$dog = new Dog("Buddy");
$cat = new Cat("Whiskers");

echo $dog->getName() . " says " . $dog->makeSound() . PHP_EOL; // ✅ Buddy says Bark!
echo $cat->getName() . " says " . $cat->makeSound() . PHP_EOL; // ✅ Whiskers says Meow!

?>
``` 

**❌ Animal აბსტრაქტული კლასიდან ობიექტის შექმნა არ შეიძლება.**    
**✅ makeSAound() აბსტრაქტული კლასის მეთოდია და ყველა შვილობილმა კლასმა თავისი იმპლემენტაცია უნდა დაამატოს.**    
**✅ შვილობილ კლასებში (Dog, Cat) გვაქვს კონკრეტული makeSound() იმპლემენტაცია.**    
**✅ შვილობილი კლასები (Dog, Cat) იყენებენ მშობელი აბსტრაქტული კლასის მეთოდს getName().**    

---

## 3. ინტერფეისების (Interfaces) გამოყენება

**📌 როდის გამოვიყენოთ ინტერფეისი?**
✅ როცა გვიონდა, რომ **ერთმა კლასმა იმპლემენტაცია გაუკეთოს რამდენიმე სხვადასხვა ტიპის ქცევას.**    
✅ როცა გვინდა **"რა უნდა გააკეთოს" კლასმა განვსაზღვროთ, მაგრამ "როგორ" - არა.    

**მაგალითი:**

```php
<?php

interface Animal {
    public function makeSound(): string;
}

class Dog implements Animal {
    public function makeSound(): string {
        return "Bark!";
    }
}

class Cat implements Animal {
    public function makeSound(): string {
        return "Meow!";
    }
}

function animalSound(Animal $animal) {
    echo $animal->makeSound() . PHP_EOL;
}

$dog = new Dog();
$cat = new Cat();

animalSound($dog); // Bark!
animalSound($cat); // Meow!

?>
```

**✅  აქ interface Animal განსაზღვრავს, რომ ყველა კლასს უნდა ჰქონდეს makeSound() მეთოდი.**    
**✅ შვილობილმა კლასებმა (Dog, Cat) თავად გადაწყვიტეს, როგორ იმუშავებს ეს მეთოდი.**    
**✅ ინტერფეისები ხელს უწყობს პოლიმორფიზმს, რადგან ერთი და იგივე მეთოდებით შეგვიძლია სხვადასხვა კკლასების გამოყენება.**    

---

## 4. აბსტრაქტული კლასი vs ინტერფეისი

| **მახასიათებელი**                                         | **Abstract class**                              | **Interface**                                      |
| --------------------------------------------------------- | ----------------------------------------------- | -------------------------------------------------- |
| **შესაძლებელია მეთოდების განსაზღვრა და იმპლემენტაცია**    | კი                                              | არა (მხოლოდ სიგნატურა)                             |
| **შესაძლებელია თვისებების (properties) განსაზღვრა**       | კი                                              | არა                                                |
| **შვილობილ კლასს შეუძლია მემკვიდრეობით მიიღოს რამდენიმე** | მხოლოდ ერთი                                     | კი (რამდენიმე ინტერფეისის იმპლემენტაცია)           |
| **როდის გამოვიყენოთ**                                     | როცა გვინდა ზოგადი ლოგიკის მემკვიდრეობით მიღება | როცა გვინდა, რომ კლასებს ჰქონდეს ერთიანი სტანდარტი |

---

## 5. აბსტრაქციის უპირატესობები
✅ **კოდის გამარტივება** - მომხმარებელი ხედავს მხოლოდ საჭირო ფუნქციონალს და არა დეტალებს.    
✅ **კოდის გადამუშავება (Reusability)** - აბსტრაქტული კლასები ზოგადი ლოგიკის გამოყენების საშუალებას იძლევა.    
✅ **მოდულარობა (Modularity)** - ინტერფეისები აძლევს დეველოპერებს თავისუფლებას სხვადასხვა იმპლემენტაცია შეასრულონ.    
✅ **პოლიმორფიზმის მხარდაჭერა** - ერთი და იგივე მეთოდები სხვადასხვა შვილობილ კლასებში შეიძლება სხვადასხვანაირად მუშაობდნენ.    

---

**🚀 დასკვნა**

✅ **Abstraction** არის **OOP-ის ერთერთი მთავარი პრინციპი**, რომელიც **ცვლის კოდის ორგანიზებას, აკეთებს მას უფრო სუფთას და გასაგებს.**    
✅ **აბსტრაქტული კლასები** და **ინტერფეისები** გამოიყენება **კოდის მოდულარობის, უსაფრთხოების და გადამუშავების (Reusability) ის უზრუნველსაყოფად.**    
✅ **ინტერფეისები** საშუალებას გვაძხლევს, **ერთმა კლასმა იმპლემენტაცია გაუკეთოს სხვადასხვა ტიპის ქცევებს,** ხოლო **აბსტრაქტული კლასები** გვაძლევსა **კჯონკრეტული ლოგიკის მემკვიდრეობით მიღების შესაძლებლობას.    