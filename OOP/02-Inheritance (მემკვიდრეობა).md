მემკვიდრეობა (**Inheritance**) საშუალებას იძლევა, რომ **შვილობილმა კლასებმა მიიღოს მშობლის კლასის თვისებები და მეთოდები** და საჭიროების შემთხვევაში მათზე საკუთარი იმპლემენტაცია გააკეთოს.


PHP ში მემკვიდრეობის გამოსაყენებლად ვიყენებთ **extends** keywords.

## ბაზისური მემკვიდრეობის მაგალითი (Property Promotion + Readonly)

PHP 8.4 ს უფრო მკაცრი ტიპიზაცია და readonly თვისებები აქვს, რაც მემკვიდრეობასთან ერთად უფრო უსაფრთხო კოდს უზრუნველყოფს.

```php
<?php

class Vehicle {
    public function __construct(
        protected readonly string $brand,
        protected readonly int $year
    ) {}

    public function getInfo(): string {
        return "Brand: {$this->brand}, Year: {$this->year}";
    }
}

class Car extends Vehicle {
    public function __construct(
        string $brand,
        int $year,
        protected readonly string $model
    ) {
        parent::__construct($brand, $year);
    }

    public function getInfo(): string {
        return parent::getInfo() . ", Model: {$this->model}";
    }
}

$car = new Car("Toyota", 2024, "Corolla");
echo $car->getInfo(); // Brand: Toyota, Year: 2024, Model: Corolla

?>
```

✅ **Readonly** - ეს ნუიშნავს რომ მონაცემები მხოლოდ ერთხელ შეიძლება შეივსოს და მათი შეცვლა შეუძლებელია.    
✅ **Property Promotion (protected)** - property  არის დაცული და ის ხელმისაყვდომია მხოლოდ ობიექტიდან სადაც არის აღწერილი ან შვილობილი ობიექტიდან.    
✅ **parent::getInfo() - ის გამოყენება** - მშობლის მეთოდს ვიყენებთ და მასზე ვაშენებთ ახალ ინფორმაციას (პოლიმორფიზმის მაგალითი).    

## 2. protected & private

- **protected**  - შვილობილ კლასებს შეუძლიათ წვდომა, მაგრამ **გარე ობიექტებს - არა**.    
- **private** - მხოლოდ იმავე კლასის შიგნით ჩანს, **შვილობილ კლასებს არ აქვთ წვდომა**.     

## 3. Final საკვანძო სიტყვა

- **final კლასსზე** - ნიშნავს, რომ ეს კლასი აღარ შეიძლება მემკვიდრეობით გადაეცეს.
- **final მეთოდზე** - ნიშნავს, რომე ამ მეთოდის გადაფარვა შვილობილ კლასში შეუძლებელია.

```php
<?php
final class Animal {
    public function makeSound() {
        return "Some sound...";
    }
}

// ❌ ეს არ იმუშავებს!
// class Dog extends Animal {}

?>
```

✅ **ეს შეცდომას გამოიწვევს, რადგან Animal კლასი final-ით არის გამოცხადებული.**


**📌 როდის გამოვიყენოთ მემკვიდრეობა?**

  

✅ როცა გინდა **კოდის გადამუშავება** (Reuse) – მაგალითად, Animal კლასში ძირითადი ლოგიკა ერთია და მხოლოდ გარკვეული დეტალები იცვლება შვილობილ კლასებში.    
✅ როცა გინდა **კლასების ურთიერთდაკავშირება** – მაგალითად, Vehicle → Car, Bike, Truck.    
✅ როცა გჭირდება **სისტემის გაფართოება** – ახალი შვილობილი კლასების დამატება მინიმალური ცვლილებით.    

  

**🚨 როდის არ უნდა გამოვიყენოთ მემკვიდრეობა?**


❌ როცა კლასები ძალიან განსხვავდებიან და არ აქვთ საერთო ლოგიკა.    
❌ როცა სჯობს **ინტერფეისები (interfaces) ან კომპოზიცია** გამოვიყენოთ.    

**🔹 შეჯამება**


| **მახასიათებელი**           | **აღწერა**                                               |
| --------------------------- | -------------------------------------------------------- |
| **extends**                 | შვილობილი კლასის შექმნისთვის გამოიყენება                 |
| **parent::method()**        | მშობლის მეთოდის გამოძახება                               |
| **parent::__constructor()** | მშობლის კონსტრუქტორის გამოძახება                         |
| **protected**               | შვილობილ კლასს აქვს წვდომა ხოლო გარე კოდიდან არ შეიძლება |
| **private**                 | მხოლო იმავე კლასის შიგნით ჩანს                           |
| **final კლასსი**            | შვილობილი კლასის შექმნა შეუძლებელია                      |
| **final მეთოდი**            | მეთოდის გადაფგარვა შვილობილ კლასში არ შეიძლება           |

**✅ დასკვნა**

  

**Inheritance (მემკვიდრეობა) PHP-ში** ძალიან სასარგებლოა, როცა გინდა **კოდის გადამუშავება და სტრუქტურიზაცია.**    

მნიშვნელოვანია გავითვალისწინოთ, რომ **ზედმეტი მემკვიდრეობა ართულებს კოდს**, ამიტომ ზოგჯერ **კომპოზიცია (Composition) ან ინტერფეისები** უკეთესი ალტერნატივაა. 