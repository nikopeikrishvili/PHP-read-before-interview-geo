
## 1. რას ნიშნავს კომპოზიცია

კომპოზიციის გამოყენებით ერთ კლასს შეუძლია გამოიყენოს მეორე კლასის **ფუნქციონალი მის შიგნით, მემკვიდრეობის (extends) გარეშე.**

**მაგალითი**

```php
<?php

class Engine {
    public function start(): string {
        return "Engine started!";
    }
}

class Car {
    private Engine $engine;

    public function __construct() {
        $this->engine = new Engine();
    }

    public function startCar(): string {
        return $this->engine->start();
    }
}

$car = new Car();
echo $car->startCar(); // Engine started!

?>
```

✅ **აქ Car არ არის Engine ის შვილობილი კლასი, მაგრამ მაინც იყენებს მის ფუნქციონალს.**
✅ **უფრო მოქნილია მემკვიდრეობაზე რადგანაც რადგანაც Car ს შეუძლია სხვა Engine კლასებიც გამოიყენოს, (მაგალითისთვის ElectricEngine - ამ შემთხვევაში უმჯობესი იქნება ერთნაირი ტიპის კლასები საერთო ინტერფეისის ქვეშ მოვაქციოთ).***

---
## 2.  რატომ ჯობია კომპოზიცია მემკვიდრეობას

**📌 პრობლემა მემკვიდრეობით (Inheritance)**

მემკვიდრეობის გამოყენება ნიშნავს, რომ **მშობელი და შვილობილი კლასები ძალიან მჭიდროდ არიან დაკავშირებული.** თუ **მშობელი კლასის ლოგიკა შეიცვლება, შვილობილ კლასებზე გავლენა ექნება.

**მაგალითი მემკვიდრეობით (პრობლემური მიდგომა)**
```php
<?php

class Engine {
    public function start(): string {
        return "Engine started!";
    }
}

class Car extends Engine { }

$car = new Car();
echo $car->start(); // Engine started!

?>
```

**❌ აქ პრობლემა ის არის, რომ Car მემკვიდრეობით იღებს Engine-ს, რაც ლოგიკურად არასწორია.
❌ მემკვიდრეობით მიღებისას Car ხდება Engine ის ნაწილი, რაც არასწორი დამოკიდებულებაა.
❌ თუ მომავალში Car-ში სხვა ტიპის Engine დაგვჭირდება, ცვლილებების შეტანა რთული იქნება.

✅ **კომპოზიცია კი ამ პრობლემას გვაცილებს, რადგან Car-ს უბრალოდ აქვს Engine ობიექტზე წვდომა და არა მემკვიდრეობის დახმარებით. 

---
## 3. Dependency Injection და კომპოზიცია

კომპოზიციის უფრო მოქნილი გზა არის **დამოკიდებულების შეყვანის დიზაინის პატერნის გამოყენება (Dependency Injection)**.

**მაგალითი, მოქნილი კომპოზიცია **

```php
<?php  
interface Engine {  
    public function start():string;  
}  
class GasEngine implements Engine {  
    public function start(): string  
    {  
        return 'Gas Engine Started!!!'."\n";  
    }}  
  
class ElectricEngine implements Engine {  
    public function start(): string  
    {  
        return 'Electric Engine Started!!!'."\n";  
    }}  
  
class Car {  
    public function __construct(private readonly Engine $engine)  
    {    }    public function start(){  
        return $this->engine->start();  
    }}  
  
$eCar = new Car(new ElectricEngine());  
$gCar = new Car(new GasEngine());  
  
echo $eCar->start();  
echo $gCar->start();
```

✅ **აქ Car არ არის დამოკიდებული კონკრეტულ Engine კლასზე - შეგვიძლია გადავცეთ ნებისმიერი ობიექტი რომელიც Engine ინტერფეისის იმპლემენტაციას ახორხიელებს.
✅ ეს კოდი უფრო მოქნილი რადგანაც ძრავის ტიპი შეგვიძლია შევცვალოთ მარტივად.

---

## 4. კომპოზიცია vs მემკვიდრეობა


| მახასიათებელი                      | კომპოზიცია                                                                            | მემკვიდრეობა                                                   |
| ---------------------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| **მიჯაჭვულობა**                    | დაბალი (Loose Coupling)                                                               | მაღალი (Tightly Coupling)                                      |
| **კოდის გადამუშავება**             | მაღალი მოქნილობა                                                                      | შეზღუდული მოქნილობა                                            |
| **შეცვლადობა (Maintainabilility)** | მარტივი შეცვლა და გაფართოება                                                          | რთულია ცვლილებები                                              |
| **შვილობილი კლასები**              | კლასებში სხვა კლასის ობიექტები არიან Propertie ბში                                    | კლასები უშუალოდ დამოკიდებულები არიან მშობლებზე                 |
| **გამოყენების სცენარი**            | როცა გვინდა რომ ერთ კლასს ჰქონდეს სხვა კლასის შესაძლებლობები **მემკვიდრეობის გარეშე** | როცა კლასები მკაფიოდ დაკავშირებულია და მემკვიდრეობა ბუნებრივია |

## 5. როდის გამოვიყენოთ კომპოზიცია
✅ როცა გვინდა **მოვახდინოთ კოდის განმეორებით გამოყენება (Reuse),** მაგრამ არ გვსურს კლასებს მჭიდრო კავშირი ქონდეთ ერთმანეთთან.
✅ როცა საჭიროა, რომ **კლაწსებმა ერთმანეთისგან დამოუკიდებლად იმუშავონ**, მაგრამ მათ გარკვეული ურთიერთქმედება მაინც ჰქონდეთ.
✅ როცა გვინდა, **მრავალჯერადი გამოყენების შესალებლობა (Reusability),** მაგალითად, როცა **მომავალში შეიძლება შეიცვალოს კონკრეტული ლოგიკა.**
✅ როცა დაგვჭირდება **Dependency Injection** ის გამოყენება.

---

## 6. როდის გამოვიყენოთ მემკვიდრეობა (Inheritance)

✅ როცა **კლასებს აქვთ მკაფიოდ განსაზღვრული მშობელ შვილობილი კავშირი** (მაგალითა, Animal -> Dog,Cat).
✅ როცა გვინდა **პოლიმორფიზმის გამოყენება** და ერთსა და იმავე ინტერფეისზე სხვადასხვა იმპლემენტაციის შექმნა.
✅ როცა **აბსტრაქტული კლასების ანდ ინტერფეისების გამოყენებაა** საჭირო, რათ აშვილობილმა კლასებმა სხვადასხვა ლოგიკა განახორციელონ.

**🚀 დასკვნა**
- **კომპოზიცია** უფრო **მოქნილია**,რადგან კლასებს ერთმანეთთან მჭიდრო დამოკიდებულება **არ აქვთ.**
- **მემკვიდრეობა** სჯობს, როცა კლასებს **თითქმის ერთნაირი ქცევა აქვთ**, და გვჭირდება **პოლიმორფიზმი**.
- **კომპოზიცია არის OOP-ში საუკეთესო პრაქტიკა,** როცა გვსურს კოდის მოდულარობა, განმეორებით გამოყენება და მარტივი ცვლილებები.

